# Acknowledgments 
Tôi bắt đầu nghiên cứu cái mà khi đó được gọi là C++0x (tiền thân của C++11) vào năm 2009. Tôi đã đăng nhiều câu hỏi lên nhóm thảo luận Usenet comp.std.c++, và tôi rất biết ơn các thành viên của cộng đồng đó (đặc biệt là Daniel Krügler) vì những bài viết rất hữu ích của họ. Trong những năm gần đây, tôi đã chuyển sang Stack Overflow khi có câu hỏi về C++11 và C++14, và tôi cũng rất cảm kích cộng đồng đó vì đã giúp tôi hiểu rõ hơn những điểm tinh tế của C++ hiện đại. 

Năm 2010, tôi chuẩn bị tài liệu cho một khóa đào tạo về C++0x (cuối cùng được xuất bản dưới tên Overview of the New C++, Artima Publishing, 2010). Cả những tài liệu đó và kiến thức của tôi đều được hưởng lợi rất nhiều từ việc kiểm tra kỹ thuật của Stephan T. Lavavej, Bernhard Merkle, Stanley Friesen, Leor Zolman, Hendrik Schober và Anthony Williams. Nếu không có sự giúp đỡ của họ, có lẽ tôi đã không thể ở vị trí để thực hiện Effective Modern C++. Tiêu đề đó, nhân tiện, được đề xuất hoặc ủng hộ bởi một số độc giả phản hồi bài đăng blog của tôi vào ngày 18 tháng 2 năm 2014, “Help me name my book,” và Andrei Alexandrescu (tác giả của Modern C++ Design, Addison-Wesley, 2001) đã rất tốt bụng khi chấp nhận tiêu đề này vì không xâm phạm vào thuật ngữ của ông ấy. 

Tôi không thể xác định nguồn gốc của tất cả thông tin trong cuốn sách này, nhưng một số nguồn đã có ảnh hưởng tương đối trực tiếp. Việc sử dụng mẫu không xác định của Mục 4 để lấy thông tin kiểu từ các trình biên dịch được gợi ý bởi Stephan T. Lavavej, và Matt P. Dziubinski đã giới thiệu Boost.TypeIndex cho tôi. Trong Mục 5, ví dụ `unsigned-std::vector<int>::size_type` từ bài viết của Andrey Karpov ngày 28 tháng 2 năm 2010, “In what way can C++0x standard help you eliminate 64-bit errors.” Ví dụ std::pair<std::string, int>/std::pair<const std::string, int> trong cùng Mục đó lấy từ bài nói của Stephan T. Lavavej tại Going Native 2012, “STL11: Magic && Secrets.” Mục 6 được lấy cảm hứng từ bài viết ngày 12 tháng 8 năm 2013 của Herb Sutter, “GotW #94 Solution: AAA Style (Almost Always Auto).” Mục 9 được thúc đẩy bởi bài đăng blog ngày 27 tháng 5 năm 2012 của Martinho Fernandes, “Handling dependent names.” Ví dụ trong Mục 12 minh họa việc nạp chồng trên các qualifier tham chiếu dựa trên câu trả lời của Casey cho câu hỏi, “What’s a use case for overloading member functions on reference qualifiers?” được đăng trên Stack Overflow vào ngày 14 tháng 1 năm 2014. Việc xử lý Mục 15 về hỗ trợ mở rộng của C++14 cho các hàm constexpr kết hợp thông tin tôi nhận được từ Rein Halbersma. Mục 16 dựa trên bài thuyết trình của Herb Sutter tại C++ and Beyond 2012, “You don’t know const and mutable.” Lời khuyên của Mục 18 về việc các hàm factory nên trả về std::unique_ptr dựa trên bài viết ngày 30 tháng 5 năm 2013 của Herb Sutter, “GotW# 90 Solution: Factories.” Trong Mục 19, fastLoadWidget được lấy từ bài thuyết trình Going Native 2013 của Herb Sutter, “My Favorite C++ 10-Liner.” Việc xử lý std::unique_ptr và các kiểu chưa hoàn chỉnh trong Mục 22 dựa trên bài viết ngày 27 tháng 11 năm 2011 của Herb Sutter, “GotW #100: Compilation Firewalls” cũng như câu trả lời của Howard Hinnant ngày 22 tháng 5 năm 2011 cho câu hỏi trên Stack Overflow, “Is std::unique_ptr<T> required to know the full definition of T?” Ví dụ về phép cộng Matrix trong Mục 25 dựa trên các bài viết của David Abrahams. Bình luận ngày 8 tháng 12 năm 2012 của JoeArgonne trên bài đăng blog ngày 30 tháng 11 năm 2012, “Another alternative to lambda move capture,” là nguồn gốc cho phương pháp dựa trên std::bind của Mục 32 để mô phỏng init capture trong C++11. Giải thích của Mục 37 về vấn đề với việc detach ngầm trong destructor của std::thread được lấy từ bài viết ngày 4 tháng 12 năm 2008 của Hans-J. Boehm, “N2802: A plea to reconsider detach-on-destruction for thread objects.” Mục 41 ban đầu được thúc đẩy bởi các cuộc thảo luận về bài đăng blog ngày 15 tháng 8 năm 2009 của David Abrahams, “Want speed? Pass by value.” Ý tưởng rằng các kiểu chỉ di chuyển xứng đáng được xử lý đặc biệt là nhờ Matthew Fioravante, trong khi phân tích về sao chép dựa trên phép gán xuất phát từ các bình luận của Howard Hinnant. Trong Mục 42, Stephan T. Lavavej và Howard Hinnant đã giúp tôi hiểu các hồ sơ hiệu suất tương đối của các hàm emplacement và insertion, và Michael Winterberg đã chỉ ra cho tôi cách mà emplacement có thể dẫn đến rò rỉ tài nguyên. (Michael ghi nhận bài thuyết trình “C++ Seasoning” của Sean Parent tại Going Native 2013 là nguồn của anh ấy). Michael cũng chỉ ra cách mà các hàm emplacement sử dụng khởi tạo trực tiếp, trong khi các hàm insertion sử dụng khởi tạo sao chép. 

Việc xem xét các bản thảo của một cuốn sách kỹ thuật là một nhiệm vụ đòi hỏi cao, tốn nhiều thời gian và hoàn toàn quan trọng, và tôi may mắn vì có rất nhiều người sẵn lòng làm điều đó cho tôi. Các bản thảo toàn bộ hoặc một phần của cuốn Effective Modern C++ đã được chính thức xem xét bởi Cassio Neri, Nate Kohl, Gerhard Kreuzer, Leor Zolman, Bart Vandewoestyne, Stephan T. Lavavej, Nevin “:-)” Liber, Rachel Cheng, Rob Stewart, Bob Steagall, Damien Watkins, Bradley E. Needham, Rainer Grimm, Fredrik Winkler, Jonathan Wakely, Herb Sutter, Andrei Alexandrescu, Eric Niebler, Thomas Becker, Roger Orr, Anthony Williams, Michael Winterberg, Benjamin Huchley, Tom Kirby-Green, Alexey A Nikitin, William Dealtry, Hubert Matthews, và Tomasz Kamiński. Tôi cũng nhận được phản hồi từ một số độc giả thông qua Early Release EBooks của O’Reilly và Rough Cuts của Safari Books Online, các bình luận trên blog của tôi (The View from Aristeia), và email. Tôi biết ơn từng người trong số này. Cuốn sách đã tốt hơn rất nhiều nhờ sự giúp đỡ của họ. 

  

Tôi đặc biệt cảm kích Stephan T. Lavavej và Rob Stewart, những người có những nhận xét chi tiết và toàn diện đến mức khiến tôi lo lắng rằng họ đã dành gần như nhiều thời gian cho cuốn sách này như tôi. Lời cảm ơn đặc biệt cũng gửi đến Leor Zolman, người ngoài việc xem xét bản thảo còn kiểm tra lại tất cả các ví dụ mã. 

  

Các đánh giá chuyên dụng của các phiên bản kỹ thuật số của cuốn sách đã được thực hiện bởi Gerhard Kreuzer, Emyr Williams, và Bradley E. Needham. 

  

Quyết định của tôi giới hạn độ dài dòng trong các hiển thị mã đến 64 ký tự (tối đa có thể hiển thị đúng trên bản in cũng như trên nhiều thiết bị kỹ thuật số khác nhau, hướng thiết bị và cấu hình phông chữ) dựa trên dữ liệu do Michael Maher cung cấp. Ashley Morgan Williams đã làm cho việc ăn uống tại Lake Oswego Pizzicato trở nên độc đáo và thú vị. Khi nói đến những chiếc Caesars cỡ lớn, cô ấy là người đáng tin cậy. 

 

Hơn 20 năm sau lần đầu tiên tôi viết sách, vợ tôi, Nancy L. Urbano, một lần nữa chịu đựng nhiều tháng của những cuộc trò chuyện lơ đễnh với một sự pha trộn của sự cam chịu, bực bội và những đợt hiểu biết và hỗ trợ đúng lúc. Trong cùng khoảng thời gian đó, chú chó của chúng tôi, Darla, phần lớn hài lòng với việc ngủ quên trong những giờ tôi dành để nhìn chằm chằm vào màn hình máy tính, nhưng cô ấy không bao giờ để tôi quên rằng có một cuộc sống bên ngoài bàn phím. 

Introduction 

 